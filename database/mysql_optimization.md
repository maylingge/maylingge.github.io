# 查询执行
   客户端/服务器端 通信协议
   
   查询缓存
   
   查询优化 
   
   调用存储引擎API拿数据

# 查询缓存
  一个对大小写敏感的哈希查找
  
  很多时候应该默认关闭查询缓存
  因为查询缓存会成为服务器的资源竞争单点
  
  ？如何提高查询命中率 多高才算好的命中率
  ？如何减少碎片
  
  

# 重构查询
## 一个复杂查询 or 多个简单查询
    使用尽可能少的查询是更好的
    但有的时候一个大查询分解为多个小查询是很有必要的
    
    ？MySQL内部处理的时间和网络响应时间比起来应该是小的多
    所以正常情况下应该是查询越少越好 因为连接成本高
    
### 删除数据时， 一次删除一部分， 两次删除直接间隔一段时间， 不过多的暂用资源， 降低对服务器的影响

### 分解关联查询， 可以让缓存更高效，在应用层做关联
    ？是不是应用层关联总是最好的？
    这些场景是更好的：应用能缓存查询结果，数据分不到不同的服务器上，查询中使用同一个数据表，IN（）代替关联查询


# 查询优化
## 查询优化器
    基于成本优化， 成本最小单位是随机读取一个4k数据页
    show status like 'last_query_cost';
    
    MySQL 依赖存储引擎提供的统计信息来评估成本
    
    查询优化器使用很多优化策略来生成一个最优的执行计划
    优化可分为静态优化和动态优化
    
    MySQL 每一次查询都是一次关联
    任何关联都执行嵌套循环关联操作（深度优先）
    重新定义关联的顺序是优化器的一个重要功能
    
    
## 优化SQL
### 重写SQL
### 创建索引
    覆盖索引： 不用回表取数据，所需数据就在索引中有
    组合索引 & 索引合并 哪个更好 依据真实情况
    添加索引原则：
    1. 最左匹配原则
       = 和 in 是可以乱序的，优化器会调整成索引可以识别/匹配的形式
       mysql会一直向右匹配（组合索引）直到遇到范围查询(范围查询是不能使用索引的)
       
    2. 尽量选择区分度高的列作为索引列
    
    3. 索引列不能参与计算
       
