# 查询执行
   客户端/服务器端 通信协议
   
   查询缓存
   
   查询优化 
   
   调用存储引擎API拿数据

# 查询缓存
  一个对大小写敏感的哈希查找
  
  很多时候应该默认关闭查询缓存
  因为查询缓存会成为服务器的资源竞争单点
  
  ？如何提高查询命中率 多高才算好的命中率
  ？如何减少碎片
  
  

# 重构查询
## 一个复杂查询 or 多个简单查询
    使用尽可能少的查询是更好的
    但有的时候一个大查询分解为多个小查询是很有必要的
    
    ？MySQL内部处理的时间和网络响应时间比起来应该是小的多
    所以正常情况下应该是查询越少越好 因为连接成本高
    
### 删除数据时， 一次删除一部分， 两次删除直接间隔一段时间， 不过多的暂用资源， 降低对服务器的影响

### 分解关联查询， 可以让缓存更高效，在应用层做关联
    ？是不是应用层关联总是最好的？
    这些场景是更好的：应用能缓存查询结果，数据分不到不同的服务器上，查询中使用同一个数据表，IN（）代替关联查询


# 查询优化
## 查询优化器
    基于成本优化， 成本最小单位是随机读取一个4k数据页
    show status like 'last_query_cost';
    
    MySQL 依赖存储引擎提供的统计信息来评估成本
    
    查询优化器使用很多优化策略来生成一个最优的执行计划
    优化可分为静态优化和动态优化
    
    MySQL 每一次查询都是一次关联
    任何关联都执行嵌套循环关联操作（深度优先）
    重新定义关联的顺序是优化器的一个重要功能
    
    
## 优化SQL
    用explain查看SQL执行计划， rows是核心指标，
    大部分rows小的语句执行一定很快（列外就是有limit的情况），优化语句基本就是在优化rows
### 重写SQL
### 创建索引
    覆盖索引： 不用回表取数据，所需数据就在索引中有
    组合索引 & 索引合并 哪个更好 依据真实情况
    添加索引原则：
    1. 最左匹配原则
       = 和 in 是可以乱序的，优化器会调整成索引可以识别/匹配的形式
       mysql会一直向右匹配（组合索引）直到遇到范围查询(范围查询是不能使用索引的)
       
    2. 尽量选择区分度高的列作为索引列
    
    3. 索引列不能参与计算
       
### 一个SQL慢的原因有哪些？
    1. 表/行被其他操作锁了 （偶尔慢）
    2. 数据库更新数据从内存到磁盘（偶尔慢）
    3. 没有索引
    4. 有索引没用到
       a) 数据库选错了
       b) 函数（运算）操作在字段上(操作符左边）

### 如何合理的创建/使用索引
    1. 索引不是越多越好，最多不超过6个，多了会影响update和insert性能
    2. 复合索引比多个单个索引好（因为MYSQL一次只能用一个索引），索引的顺序很重要
        创建了索引（A, B, C) 等同于创建了三个索引 （A), (A, B), (A, B, C)
        where 和 order by字段， where字段在前，因为先使用条件过滤数据再对数据排序
        尽量不要对数据进行排序 使用数据库默认排序结果如果能满足要求的话
    3. 特殊查询条件不能应用索引
        like ’%abc%‘   # 前面的通配符导致不能应用索引，除非必要， 否则不要在关键字前加通配符
        where子句中使用了 !=   
                         IS NULL, IS NOT NULL (设置默认值为0)
                         or （使用union all 或union替代） 
                         IN , NOT IN (between, exist, left join)
                         条件字段做了表达式操作
        
